package gov.nasa.jpf.jdart.taint;

/*Generated by MPS */

import gov.nasa.jpf.vm.VMListener;
import gov.nasa.jpf.vm.VM;
import gov.nasa.jpf.vm.ThreadInfo;
import gov.nasa.jpf.vm.Instruction;
import gov.nasa.jpf.vm.ElementInfo;
import gov.nasa.jpf.jvm.ClassFile;
import gov.nasa.jpf.vm.ClassInfo;
import gov.nasa.jpf.vm.ChoiceGenerator;
import gov.nasa.jpf.vm.MethodInfo;
import gov.nasa.jpf.vm.StackFrame;
import gov.nasa.jpf.vm.NativeStackFrame;
import gov.nasa.jpf.jdart.security.TaintContainer;
import gov.nasa.jpf.jvm.JVMStackFrame;
import gov.nasa.jpf.jdart.security.TaintedVariable;
import gov.nasa.jpf.vm.LocalVarInfo;
import gov.nasa.jpf.jdart.objects.SymbolicString;
import gov.nasa.jpf.jdart.objects.SymbolicObject;
import gov.nasa.jpf.JPFException;
import java.util.Arrays;

public class SQLInjectionTaintInjector extends TaintChecker implements VMListener {

  @Override
  public void vmInitialized(VM vm) {
  }
  @Override
  public void executeInstruction(VM vm, ThreadInfo info, Instruction instruction) {
  }
  @Override
  public void instructionExecuted(VM vm, ThreadInfo info, Instruction instruction, Instruction instruction1) {
  }
  @Override
  public void threadStarted(VM vm, ThreadInfo info) {
  }
  @Override
  public void threadBlocked(VM vm, ThreadInfo info, ElementInfo info1) {
  }
  @Override
  public void threadWaiting(VM vm, ThreadInfo info) {
  }
  @Override
  public void threadNotified(VM vm, ThreadInfo info) {
  }
  @Override
  public void threadInterrupted(VM vm, ThreadInfo info) {
  }
  @Override
  public void threadTerminated(VM vm, ThreadInfo info) {
  }
  @Override
  public void threadScheduled(VM vm, ThreadInfo info) {
  }
  @Override
  public void loadClass(VM vm, ClassFile file) {
  }
  @Override
  public void classLoaded(VM vm, ClassInfo info) {
  }
  @Override
  public void objectCreated(VM vm, ThreadInfo info, ElementInfo info1) {
  }
  @Override
  public void objectReleased(VM vm, ThreadInfo info, ElementInfo info1) {
  }
  @Override
  public void objectLocked(VM vm, ThreadInfo info, ElementInfo info1) {
  }
  @Override
  public void objectUnlocked(VM vm, ThreadInfo info, ElementInfo info1) {
  }
  @Override
  public void objectWait(VM vm, ThreadInfo info, ElementInfo info1) {
  }
  @Override
  public void objectNotify(VM vm, ThreadInfo info, ElementInfo info1) {
  }
  @Override
  public void objectNotifyAll(VM vm, ThreadInfo info, ElementInfo info1) {
  }
  @Override
  public void objectExposed(VM vm, ThreadInfo info, ElementInfo info1, ElementInfo info2) {
  }
  @Override
  public void objectShared(VM vm, ThreadInfo info, ElementInfo info1) {
  }
  @Override
  public void gcBegin(VM vm) {
  }
  @Override
  public void gcEnd(VM vm) {
  }
  @Override
  public void exceptionThrown(VM vm, ThreadInfo info, ElementInfo info1) {
  }
  @Override
  public void exceptionBailout(VM vm, ThreadInfo info) {
  }
  @Override
  public void exceptionHandled(VM vm, ThreadInfo info) {
  }
  @Override
  public void choiceGeneratorRegistered(VM vm, ChoiceGenerator<?> generator, ThreadInfo info, Instruction instruction) {
  }
  @Override
  public void choiceGeneratorSet(VM vm, ChoiceGenerator<?> generator) {
  }
  @Override
  public void choiceGeneratorAdvanced(VM vm, ChoiceGenerator<?> generator) {
  }
  @Override
  public void choiceGeneratorProcessed(VM vm, ChoiceGenerator<?> generator) {
  }
  @Override
  public void methodEntered(VM vm, ThreadInfo currentThread, MethodInfo enteredMethod) {
    {
      // This block checks for the declared sink methods 
      boolean conditionTrigger = false;

      conditionTrigger |= checkClassTrigger_java_sql_Statement_a0a2(vm, currentThread, enteredMethod);
      conditionTrigger |= checkClassTrigger_java_sql_Connection_b0a2(vm, currentThread, enteredMethod);
      conditionTrigger |= checkClassTrigger_org_springframework_jdbc_core_JdbcTemplate_c0a2(vm, currentThread, enteredMethod);

      // The if-clause is triggered, when at least one class with at least one method is matched 
      if (conditionTrigger) {
        StackFrame stackFrame = currentThread.getTopFrame();
        if (stackFrame instanceof NativeStackFrame) {
          NativeStackFrame nativeStackFrame = (NativeStackFrame) stackFrame;
          Object[] args = nativeStackFrame.getArguments();
          for (int i = 0; i < args.length; i++) {
            ElementInfo elementInfo = (ElementInfo) args[i];
            TaintContainer taintContainer = elementInfo.getObjectAttr(TaintContainer.class);
            checkTaintContainerForSQLInjection(currentThread, enteredMethod, taintContainer);
          }
        } else if (stackFrame instanceof JVMStackFrame) {
          JVMStackFrame jvmStackFrame = (JVMStackFrame) stackFrame;
          Object[] args = jvmStackFrame.getArgumentValues(currentThread);
          // Check for each argument whether it is tainted 
          for (int i = 0; i < args.length; i++) {
            ElementInfo elementInfo = (ElementInfo) args[i];
            TaintContainer taintContainer = elementInfo.getObjectAttr(TaintContainer.class);
            checkTaintContainerForSQLInjection(currentThread, enteredMethod, taintContainer);
          }
        }
      }
    }
  }

  @Override
  public void methodExited(VM vm, ThreadInfo currentThread, MethodInfo exitedMethod) {
    {
      // This block checks for the declared source methods  
      boolean conditionTrigger = false;
      StackFrame stackFrame = currentThread.getTopFrame();

      conditionTrigger |= checkClassTrigger_HttpServletRequest_a0a2(vm, currentThread, exitedMethod);

      // The if-clause is triggered, when at least one class with at least one method is matched 
      if (conditionTrigger) {
        Object resultAttribute = null;
        // Get ResultAttribute from StackFrame 
        if (stackFrame instanceof NativeStackFrame) {
          NativeStackFrame nativeStackFrame = (NativeStackFrame) stackFrame;
          resultAttribute = nativeStackFrame.getResultAttr();
        } else if (stackFrame instanceof JVMStackFrame) {
          JVMStackFrame jvmStackFrame = ((JVMStackFrame) stackFrame);
          resultAttribute = jvmStackFrame.getResultAttr();
        }
        // Use resultAttribute to access TaintContainer and set TaintVariable 
        if (resultAttribute == null) {
          // It is not allowed to add a new Container in the Listener 
        } else if (resultAttribute instanceof TaintedVariable) {
          // Declared sink method set taint variable to 'true' 
          ((TaintedVariable) resultAttribute).isSQLInjectionTainted = true;
        }
      }
    }
  }
  /**
   * This method checks for taint
   * 
   * @param threadInfo The current thread
   * @param methodInfo The current method
   * @param container The container that will be checked for taint 'SQLInjection'
   */
  protected void checkTaintContainerForSQLInjection(ThreadInfo threadInfo, MethodInfo methodInfo, TaintContainer container) {
    // Checks whether the container is existing and has the taint flag set 
    if (container != null && container.isSQLInjectionTainted) {
      String message = "Found taint of type 'SQLInjection' in Method: " + methodInfo.getName();
      logger.warning(message);
      threadInfo.createAndThrowException("errors.Taint");
    }
  }

  /**
   * This method checks for a specific method and class with given parameters
   * 
   * @param vm The current virtual machine
   * @param currentThread The currently active thread
   * @param currentMethod The exited method that triggered the process
   * @return Return whether the entered/exited method matches the method '*' of class 'java.sql.Statement' with parameters 'sql'
   */
  protected boolean checkClassTrigger_java_sql_Statement_a0a2(VM vm, ThreadInfo currentThread, MethodInfo currentMethod) {
    StackFrame stackFrame = currentThread.getTopFrame();
    String currentClassName = currentMethod.getClass().getName();
    String currentMethodName = currentMethod.getName();
    boolean classTrigger = true;

    // Check for the specified class 
    classTrigger &= currentClassName.equals("java.sql.Statement");

    // Check for the specified method 
    classTrigger &= !(currentMethod.isInit());

    // Collect method parameters 
    LocalVarInfo[] arguments = stackFrame.getLocalVars();

    if (arguments != null) {
      // Check for length of passed arguments 
      classTrigger &= arguments.length == 1;
    }
    checkParameter_sql_a0a2(currentThread, currentMethodName);

    return classTrigger;
  }
  /**
   * This method checks for a specific method and class with given parameters
   * 
   * @param vm The current virtual machine
   * @param currentThread The currently active thread
   * @param currentMethod The exited method that triggered the process
   * @return Return whether the entered/exited method matches the method '*' of class 'java.sql.Connection' with parameters 'sql'
   */
  protected boolean checkClassTrigger_java_sql_Connection_b0a2(VM vm, ThreadInfo currentThread, MethodInfo currentMethod) {
    StackFrame stackFrame = currentThread.getTopFrame();
    String currentClassName = currentMethod.getClass().getName();
    String currentMethodName = currentMethod.getName();
    boolean classTrigger = true;

    // Check for the specified class 
    classTrigger &= currentClassName.equals("java.sql.Connection");

    // Check for the specified method 
    classTrigger &= !(currentMethod.isInit());

    // Collect method parameters 
    LocalVarInfo[] arguments = stackFrame.getLocalVars();

    if (arguments != null) {
      // Check for length of passed arguments 
      classTrigger &= arguments.length == 1;
    }
    checkParameter_sql_b0a2(currentThread, currentMethodName);

    return classTrigger;
  }
  /**
   * This method checks for a specific method and class with given parameters
   * 
   * @param vm The current virtual machine
   * @param currentThread The currently active thread
   * @param currentMethod The exited method that triggered the process
   * @return Return whether the entered/exited method matches the method '*' of class 'org.springframework.jdbc.core.JdbcTemplate' with parameters 'sql'
   */
  protected boolean checkClassTrigger_org_springframework_jdbc_core_JdbcTemplate_c0a2(VM vm, ThreadInfo currentThread, MethodInfo currentMethod) {
    StackFrame stackFrame = currentThread.getTopFrame();
    String currentClassName = currentMethod.getClass().getName();
    String currentMethodName = currentMethod.getName();
    boolean classTrigger = true;

    // Check for the specified class 
    classTrigger &= currentClassName.equals("org.springframework.jdbc.core.JdbcTemplate");

    // Check for the specified method 
    classTrigger &= !(currentMethod.isInit());

    // Collect method parameters 
    LocalVarInfo[] arguments = stackFrame.getLocalVars();

    if (arguments != null) {
      // Check for length of passed arguments 
      classTrigger &= arguments.length == 1;
    }
    checkParameter_sql_c0a2(currentThread, currentMethodName);

    return classTrigger;
  }
  /**
   * This method checks for a specific method and class with given parameters
   * 
   * @param vm The current virtual machine
   * @param currentThread The currently active thread
   * @param currentMethod The exited method that triggered the process
   * @return Return whether the entered/exited method matches the method 'get' of class 'HttpServletRequest' with parameters 'none'
   */
  protected boolean checkClassTrigger_HttpServletRequest_a0a2(VM vm, ThreadInfo currentThread, MethodInfo currentMethod) {
    StackFrame stackFrame = currentThread.getTopFrame();
    String currentClassName = currentMethod.getClass().getName();
    String currentMethodName = currentMethod.getName();
    boolean classTrigger = true;

    // Check for the specified class 
    classTrigger &= currentClassName.equals("HttpServletRequest");

    // Check for the specified method 
    classTrigger &= currentMethodName.startsWith("get");
    classTrigger &= !(currentMethod.isInit());

    // Collect method parameters 
    LocalVarInfo[] arguments = stackFrame.getLocalVars();

    if (arguments != null) {
      // Check for length of passed arguments 
      classTrigger &= arguments.length == 0;
    }

    return classTrigger;
  }

  /**
   * This method checks the parameters of the current method for taint violations
   * 
   * @param threadInfo The current thread
   * @param methodName The name of the current method
   */
  protected void checkParameter_sql_a0a2(ThreadInfo threadInfo, String methodName) {
    StackFrame stackFrame = threadInfo.getTopFrame();
    try {
      // Check if the specified variable is present as a parameter of the method 
      int variableReference = stackFrame.getLocalVariable("sql");
      logger.fine();
      ElementInfo elementInfo = threadInfo.getElementInfo(variableReference);
      // Check whether the variable is a reference array and handle it accordingly 
      if (!(elementInfo.isReferenceArray())) {
        // Get symbolic information of variable 
        SymbolicString symbolicQuery = elementInfo.getObjectAttr(SymbolicString.class);
        // Check symbolic information 
        checkSymbolicString(symbolicQuery, elementInfo.asString(), methodName, threadInfo);
      } else {
        for (int info : elementInfo.asReferenceArray()) {
          ElementInfo tempInfo = threadInfo.getElementInfo(info);
          // Get symbolic information 
          SymbolicString symbolicQuery = tempInfo.getObjectAttr(SymbolicObject.class);
          // Check symbolic information 
          checkSymbolicString(symbolicQuery, tempInfo.asString(), methodName, threadInfo);
        }
      }
    } catch (JPFException e) {
      e.printStackTrace();
      logger.warning(methodName + " has been checked for a 'sql' parameter but couldn't find any.");
      logger.info("Found the following parameters instead: /%", Arrays.toString(stackFrame.getLocalVars()));
    }
  }
  /**
   * This method checks the parameters of the current method for taint violations
   * 
   * @param threadInfo The current thread
   * @param methodName The name of the current method
   */
  protected void checkParameter_sql_b0a2(ThreadInfo threadInfo, String methodName) {
    StackFrame stackFrame = threadInfo.getTopFrame();
    try {
      // Check if the specified variable is present as a parameter of the method 
      int variableReference = stackFrame.getLocalVariable("sql");
      logger.fine();
      ElementInfo elementInfo = threadInfo.getElementInfo(variableReference);
      // Check whether the variable is a reference array and handle it accordingly 
      if (!(elementInfo.isReferenceArray())) {
        // Get symbolic information of variable 
        SymbolicString symbolicQuery = elementInfo.getObjectAttr(SymbolicString.class);
        // Check symbolic information 
        checkSymbolicString(symbolicQuery, elementInfo.asString(), methodName, threadInfo);
      } else {
        for (int info : elementInfo.asReferenceArray()) {
          ElementInfo tempInfo = threadInfo.getElementInfo(info);
          // Get symbolic information 
          SymbolicString symbolicQuery = tempInfo.getObjectAttr(SymbolicObject.class);
          // Check symbolic information 
          checkSymbolicString(symbolicQuery, tempInfo.asString(), methodName, threadInfo);
        }
      }
    } catch (JPFException e) {
      e.printStackTrace();
      logger.warning(methodName + " has been checked for a 'sql' parameter but couldn't find any.");
      logger.info("Found the following parameters instead: /%", Arrays.toString(stackFrame.getLocalVars()));
    }
  }
  /**
   * This method checks the parameters of the current method for taint violations
   * 
   * @param threadInfo The current thread
   * @param methodName The name of the current method
   */
  protected void checkParameter_sql_c0a2(ThreadInfo threadInfo, String methodName) {
    StackFrame stackFrame = threadInfo.getTopFrame();
    try {
      // Check if the specified variable is present as a parameter of the method 
      int variableReference = stackFrame.getLocalVariable("sql");
      logger.fine();
      ElementInfo elementInfo = threadInfo.getElementInfo(variableReference);
      // Check whether the variable is a reference array and handle it accordingly 
      if (!(elementInfo.isReferenceArray())) {
        // Get symbolic information of variable 
        SymbolicString symbolicQuery = elementInfo.getObjectAttr(SymbolicString.class);
        // Check symbolic information 
        checkSymbolicString(symbolicQuery, elementInfo.asString(), methodName, threadInfo);
      } else {
        for (int info : elementInfo.asReferenceArray()) {
          ElementInfo tempInfo = threadInfo.getElementInfo(info);
          // Get symbolic information 
          SymbolicString symbolicQuery = tempInfo.getObjectAttr(SymbolicObject.class);
          // Check symbolic information 
          checkSymbolicString(symbolicQuery, tempInfo.asString(), methodName, threadInfo);
        }
      }
    } catch (JPFException e) {
      e.printStackTrace();
      logger.warning(methodName + " has been checked for a 'sql' parameter but couldn't find any.");
      logger.info("Found the following parameters instead: /%", Arrays.toString(stackFrame.getLocalVars()));
    }
  }

}
